\chapter{ESTADO DA ARTE}
\label{cap:estadoarte}

\section{Sistemas de Tempo Real}
\subsection{Conceitos}
\subsection{Classificação}
\subsection{Algoritmos de Escalonamento}

\section{Sistemas Operacionais de Tempo Real}
Segundo \cite{Rostedt2007} um Sistema Operacional de Tempo Real (SOTR) tem como propósito principal, além daqueles inerentes a todo sistema operacional, proporcionar um ambiente de desenvolvimento e execução previsível e determinístico de forma que as tarefas definidas por um suário sejam executadas corretamente dentro dos prazos definidos nas especificações do sistema. Não são seus objetivos primeiros, embora sejam desejáveis, a redução do tempo entre uma ação e uma resposta a esta ação, redução da latência de execução de tarefas ou o aumento da velocidade do sistema. Um SOTR deve fornecer a seus usuários um ambiente em que as ações de uma determinada aplicação possam ser previstas de forma determinística, qualquer que seja a carga sobre o sistema. O senso comum nos faz pensar que um SOTR possui um desempenho geral melhor que um Sistema Operacional de Propósito Geral (SOPG). Embora um SOTR de qualidade possa ter um desempenho geral equivalente a um SOPG, o primeiro sacrificará esta performance em detrimento da previsibilidade. SOPG podem, em 99,9\% dos casos, executar tarefas com um desempenho melhor que um SOTR, todavia nos 0,01\% dos casos restantes o tempo de execução de uma tarefa pode ser até 100 vezes maior do que o limite estabelecido por um sistema de tempo real crítico, mais que suficiente para reprovar o sistema. Embora um SOTR execute um conjunto de tarefas num tempo maior que um SOPG, o usuário tem a garantia de que as tarefas serão executadas dentro dos prazos estabelecidos.

Além das garantias de tempo relacionadas a execução de tarefas, um SOTR deve atender a requisitos referentes a responsividade. Quando um SOTR é submetido a um estímulo, seja interno ou externo, deve garantir que sua resposta é rápida o suficiente para atender aos requisitos temporais do sistema.

Como em qualquer sistema que lida com estímulos, os SOTR estão sujeitos a ocorrência de latências, um intervalo de tempo entre a percepção de um evento e a produção de uma resposta correspondente a este evento. Um evento pode ser um estímulo externo, como uma interrupção de hardware indicando o alarme de um relógio do sistema, ou um estímulo interno como uma \textit{thread} que foi colocada no estado pronto a espera para ser executada. O conhecimento dos valores de latências de um sistema são de grande importância para a escolha de um SOTR e para a determinação precisa dos tempos de execução de um conjunto de tarefas. Sistemas computacionais, conforme \cite{Rostedt2007}, estão sujeitos a algumas causas comuns de latência: latência provocada por interrupção, latência provocada pelo algoritmo de escalonamento, latência provocada por inversão de prioridade e latência provocada por inversão de interrupção.  

A latência provocada por interrupções corresponde ao intervalo de tempo entre a ocorrência do sinal de interrupção e o momento em que a rotina de tratamento é executada. A latência provocada pelo algoritmo de escalonamento é o tempo decorrido entre o instante em que uma tarefa é colocado no estado de pronto e o início da execução da tarefa. A latência por inversão de prioridade o corre em SOTR que suportam algoritmos de escalonamento baseados em prioridades e representa o tempo que uma \textit{thread} de prioridade alta espera pera utilizar um recurso que está sendo usado por uma \textit{thread} de menor prioridade. A latência por inversão de interrupção corresponde ao tempo que uma \textit{thread} de alta prioridade espera pelo termino da execução de uma tarefa de tratamento de interrupção de baixa prioridade termine sua execução. (Explicar melhor!!!)

- Mais características dos SOTR!!!
\subsection{Linux}
\subsection{Implementações}

\section{Patch PREEMPT-RT}

\section{RTAI}

