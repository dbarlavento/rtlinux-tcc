\chapter{AVALIAÇÃO E COMPARAÇÃO DE SOTR}
\label{cap:projeto}

A avaliação de um SOTR é definida principalmente pela capacidade de suas características atenderem aos requisitos de um determinado projeto, o que pode envolver diversas variáveis que alteram o desempenho do sistema em várias circunstâncias diferentes. Outros parâmetros relacionados a requisitos não funcionais de uma aplicação podem ter um peso maior ou menor na avaliação de um SOTR, como: suporte e documentação, reputação dos desenvolvedores, custo, integração com sistemas legados, etc, estes corroboram com o número de fatores que tornam a comparação entre SOTR algo, no mínimo, confuso.

Avaliações de desempenho mais completas de SOTR normalmente são baseadas na observação do sistema como aplicação destinada a fins específicos. Estas avaliações são difíceis de generalizar e portar para outras soluções e arquiteturas de destino diferentes da proposta original dos testes. A escolha de parâmetros quantitativos que sejam comuns a maioria dos sistemas de tempo real, e que estejam diretamente relacionados a execução dos principais casos em que estes sistemas se aplicam, facilita a comparação entre as diversas soluções existentes e proporcionam uma excelente forma de avaliação dos SOTR.

Um SO tem como principal finalidade fornecer um ambiente em que certas funcionalidades do sistema estejam ocultas ao desenvolvedor, proporcionando-lhe uma camada de abstração sobre a qual possa maximizar seu trabalho utilizando uma interface de programação mais amigável. Além desta finalidade comum a todos os SO, um SOTR, deve criar um ambiente de desenvolvimento previsível e determinístico qualquer que seja a carga do sistema a fim de que aplicações de tempo real possam ser executadas e seus requisitos temporais sejam respeitados. 

Um SOTR é dito previsível quando fornece garantias de que tarefas de tempo real sejam executadas respeitando os prazos definidos pelo pior caso de tempo de execução (\textit{Worst Case Execution Time} ou WCET, e determinístico quando torna possível conhecer os valores de tempo máximo de execução de cada uma das suas chamadas de sistema, os valores de tempo refente as latências que surgem devido as operações do sistema. É importante notar que estes valores de tempo podem variar de acordo com a arquitetura do processador em que o sistema é executado, com o código gerado pelo compilador utilizado para gerar o sistema, com os algoritmos utilizados e com a qualidade das suas respectivas implementações.

Como geralmente são sistemas reativos, é comum a SOTR lidar com interrupções, sejam provocadas por estímulos externos, sejam provocadas por atividades concorrentes. A latência de interrupção corresponde ao intervalo de tempo decorrido entre a chegada de um sinal de interrupção ao processador e o início da rotina de tratamento correspondente. É característica desejável de um SOTR que este intervalo de tempo seja o menor possível.

A latência por troca de contexto é uma característica intrínseca ao escalonador do sistema e surge quando ele alterna o uso da CPU entre os diferentes processos em atividade. Pode ser definida como o intervalo de tempo decorrido entre o momento em que um processo é interrompido e o momento em que um novo processo executa sua primeira linha de código. Bons algoritmos de escalonamento, e consequentemente suas implementações, devem comutar a execução de tarefas no menor tempo possível evitando assim a sobrecarga da CPU com esta tarefa.

Embora o senso comum nos diga que um SOTR deva reduzir a latência entre um estímulos e suas respectivas respostas e aumentar a velocidade do sistema como um todo, provê estas características não são seu principal objetivo, embora sejam bastante desejáveis, e seus valores são de grande importância no que diz respeito ao atendimento de requisitos relacionados com a responsividade do sistema ou seja ao ser submetido a um estímulo, interno ou externo, um SOTR, deve garantir que uma resposta deve ser rápida o suficiente para atender a estes requisitos.

\section{Parâmetros e premissas utilizados na Avaliação}

\section{O Ambiente de Testes}
Na comparação entre diferentes SO, e mais especificamente de SOTR,  é importante que a configuração do hardware utilizado nos testes propostos seja igual ou no mínimo equivalente, isso garante que os resultados obtidos sejam consistentes e que não tenham sido influenciados por funcionalidades específicas de uma determinada configuração de hardware.

O hardware utilizado para testar as duas soluções de tempo real escolhidas foi um netbook Acer, modelo Aspire One D250-1023, processador com arquitetura x86, Intel Aton N270, clock de 1,60GHz, memória cache L2 de 512KB, 1GB de memória DDR2-533, disco rígido de 320GB SATA.

Ambas as soluções de tempo real testadas usam como base o sistema operacional Linux e a distribuição escolhida foi Debian 8.8 (Jessie) para processadores de 32 bits. A distribuição Debian foi escolhida, dada a facilidade de se produzir um sistema com funcionalidades reduzidas, sua ampla documentação, sua grande coleção de pacotes contendo programas e bibliotecas pré compilados e por ser a base de inúmeras outras distribuições que se aplicam de servidores a sistemas embarcados. 

Foi considerado de grande importância produzir \textit{kernels} com configurações idênticas, com exceção das opções específicas exigidas por cada uma das soluções, para que recursos específicos não alterassem o desempenho dos sistemas de forma a favorecer uma das soluções testadas. As configurações utilizadas tiveram como ponto de partida a versão \textit{vanilla} de cada \textit{kernel}. A versão utilizada do \textit{patch PREEMPT-RT} foi a 4.4.17-rt25 publicada em 25 de agosto de 2016, aplicado sobre um \textit{kernel}, \textit{vanilla}, versão 4.4.17. A versão testada do RTAI foi a 5.0.1 publicada em 15 de maio de 2017, o \textit{patch HAL} foi aplicado em um \textit{kernel}, \textit{vanilla}, versão 4.4.43. Vale mencionar que não existem versões do kernel que sejam suportadas por ambas as soluções simultaneamente.

\subsection{Instalação dos Sistemas e Testes Preliminares}
As soluções estudadas foram submetidos a testes preliminares, utilizados tanto para identificar possíveis falhas nos processos de instalação, como para identificar funcionalidades do \textit{kernel} que pudessem alterar o desempenho e o determinismo do sistema. Nestes testes o principal parâmetro observado foi a latência (QUAL LATÊNCIA!!!) do sistema. Embora a redução de latência (QUAL!!!), como dito anteriormente, não seja um dos principais objetivos de um SOTR, é de vital importância, junto com os outros parâmetros vistos anteriormente, que seus valores sejam conhecidos para que o sistema possa ser classificado como determinístico. Os valores de latência obtidos como resultado dos testes preliminares também serviram como referência para avaliar a qualidade e a uniformidade dos resultados obtidos com os benchmarks desenvolvidos neste trabalho.

Os testes preliminares foram executados por meio de ferramentas recomendadas e fornecidas pelos próprios desenvolvedores dos sistemas avaliados. Foram utilizados os programas: \textit{Latency}, para testes executados no \textit{RTAI} e \textit{Cyclictest}, para testes executados no \textit{kernel} com o patch \textit{PREEMPT-RT} aplicado. O algoritmo de medição do programa \textit{Cyclictest} foi utilizado como base para os testes desenvolvidos neste trabalho.

----Falar sobre o programa Latency ----

O programa \textit{Cyclictest} é fornecido junto a suíte \textit{rt-tests}, um conjunto de ferramentas para teste de sistemas de tempo real desenvolvidas e mantidas pelos desenvolvedores do \textit{kernel Linux} e hospedada no próprio repositório do \textit{kernel}.

O programa \textit{Cyclictest} mede com alto grau de precisão, os resultados são fornecidos em microssegundos, a latência do sistema para um número definido de tarefas. Mostrou-se de extrema utilidade seu recurso que possibilita o rastreio de funcionalidades do \textit{kernel} que provocam o aumento da latência do sistema, por meio da função \textit{FTRACER}. Este recurso foi utilizado para produzir uma configuração adequada do \textit{kernel linux}.
Para que os valores das medições, obtidos com os testes, sejam válidos, é preciso que os testes sejam executados diversas vezes por um período de tempo suficiente longo e que os recursos do sistema (entradas, saídas, CPU, etc) estejam sobrecarregados, reproduzindo um cenário com a pior situação possível para a execução de uma aplicação de tempo real. Como os programas \textit{Cyclictest} e \textit{Latency} medem a latência do sistema, um cenário adequado de sobrecarga é o uso intensivo do processador, que no pior caso deve estar com valores próximos de 100\% de utilização  com poucas variações durante o período de execução dos testes. A solução adotada para produzir esse cenário foi a proposta por Geusik Lin. Esta abordagem, além de proporcionar o uso de 100\% do processador, possui uma construção simples que utiliza um conjunto de instruções e programas que já se encontram pré instalados na maioria das distribuições \textit{Linux}.

\subsection{Configuração do \textit{Kernel}}  
Rever funcionalidades apontadas como vilãs da latência!

Algumas funcionalidades do \textit{kernel}, como \textit{debug}, gerenciamento de energia, paginação, e consequentemente acessos a disco, podem comprometer a previsibilidade das aplicações de tempo real, para evitar estes problemas, as funcionalidades de \textit{debug} e gerenciamento e economia de energia do \textit{kernel} foram desabilitadas, os problemas relacionados a paginação e acessos a disco foram resolvidos nas próprias aplicações como veremos mais adiante. Embora esta configuração não tenha apresentado problemas no \textit{hardware} de teste, a ausência de recursos de gerenciamento de energia inviabilizou o carregamento do \textit{kernel} em outras configurações de \textit{hardware}. Como este trabalho trata do teste de soluções de tempo real que executam sobre sistemas monoprocessados a funcionalidade do \textit{kernel} que concede suporte a \textit{SMP} foi desabilitada.

Para que um sistema operacional possa executar aplicações de tempo real é necessário que o sistema possua suporte a relógios com uma boa granularidade e precisão, assim as opções do \textit{kernel} relacionadas aos relógios de alta precisão (High Resolution Timer Support) foram habilitadas. Como sistemas de tempo real normalmente são sistemas reativos, seguindo as recomendações da configuração do kernel, a opção Clock Frequency foi configurada para 1000 Hz.

\subsection{Erros e Falhas Encontradas}

\section{\textit{Benchmarks}}
